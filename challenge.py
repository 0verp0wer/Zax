"""                                                             
Welcome to Project ZAX, an obfuscated challenge made by over_on_top on discord aka overpower.
Difficulty: [20/100]

▗▄▄▄▄▖ ▗▄▖ ▗▖  ▗▖
   ▗▞▘▐▌ ▐▌ ▝▚▞▘ 
 ▗▞▘  ▐▛▀▜▌  ▐▌  
▐▙▄▄▄▖▐▌ ▐▌▗▞▘▝▚▖
                    
If you are still reading this, it means you want to de-obfuscate this challenge, I wish you have fun and good luck
Goal of the challenge: recreate the source code
"""

lvj__= lambda: getattr(__builtins__, "%c%c%c" % \
               tuple(map(lambda mvk__: (mvk__)*2 if mvk__ <= 60 else (mvk__) if mvk__ > 1 else chr(__mvk),(57, 52, 99)))[::-1])
cva__ = (lambda _: 0)
def hvf() -> (kvi__:="ov%sr %s" % ("e", ("rew" + "op")[::-1])) and None:
    globals()["a"] = "a"
    gvs__=iter([False, True] * 28)
    dva__=iter(["s", "i", "_", "o", "e", "c", "s"])
    cvf__="class"
    (gve__:=cva__)\
    and (\
        dvb__ := lambda *fvd: [*range(type(5).__call__(False |(\
            {}\
                ==\
                    [])&\
                \
            fvd[0])\
                )]) and (
                    evc__ := dict\
                                ({a: f for a,f in zip([],\
                                            {})})) and \
\
                                                ...;...;          a;        a;    a;\
                                                     a;          a;a;        a;  a;\
                                                    a;          a;  a;        a;a;\
                                                   a;          a;    a;        a;\
                                                  a;          a;...;a;a;      a; a;\
                                                a;...;...;   a;        a;    a;   a;\
\
    (ivg__ :=([*[0x0, 5]])) and (jvh__ := getattr(gve__, "_d_cc"[::2] + "_".__add__("_ss").__add__(a).__add__("l")[::-1])) and\
(
    nvl__ := (lambda: "")() if (lambda:False) else "over_on_top"
) or (tvq__:=getattr(str, "__na%s" % "__em"[::-1]) + getattr(int, "__name__")[0] + "gn"[::-1]) and (ovm__:=(pvn__:=lambda: __builtins__)) and {} or\
    (qvo__:=lambda rvp__:getattr(pvn__(), "_".__mul__(2) + (svq__:=("portion"[1:4] + ("%s%c" % ("mi"[-1:None:-1], "p"))))[3:] + svq__[:3] + "__")(rvp__)) and \
(svq__:=(uva__:=(qvo__(tvq__)))) and () or [] or {} or (__:="__") and\
    (vvb__:=getattr) and (zvs__:= vvb__(svq__, nvl__.join(map(lambda fva__: next(dva__) if next(gvs__) else fva__, "accoiflxwdrnage")))) and\
        (fvn__:= ["builtins", "over_on_top", "_"*2, "0verp0wer", "__%c%s%c" % ("b", "sa"[::-1], "e") + "_" * 2, "sys", "string", \
            "__b%sin%s_" % ("tliu"[::-1], "d" and "s_"), "%c%s%s" % ("e" or "f", "ex"[::-1], "c"), "%se%c" % (("s" or "f") + "ddik"[::-1], "r"), \
                "daemon", __ + "sub%s%s__" % (cvf__, "glasses"[5:]), "exec", "zax"]) and (lva__:=(nvc__ for nvc__ in fvn__ if fvn__.count(nvc__) == 1)) and\
        (mvk__:=lambda evc_:(getattr(jvh__, "%s" % (evc_)))) and (fvn__:=list(("__base__", "%s%s" % (__ + "b" or not "d", "ict" if "f" and not "a" else \
            "uiltins" + "__" or "__"), "exec", __,  __ + "b%s" % ("__base__"[3:-2] if not "exec" and not "base64" else "__builtins__"[3:-2]) + __, \
                "setattr", __,  ("_"*2 if "n" else "") + "%c%s%s" % (115, chr(117) + chr(98) if "hooked" else "p", f"classes{__}" if "detected" else "er") ,\
                    "getattr", "%c%s" % ("a" and "e", "xec" if "sys" else "lse"), "%s%c%c" % ("xe"[::-1], "e", chr(99))))) and (lvn__:=iter(type([])(lva__))) \
                        and (nvs__:=(lambda: (jvh__ := mvk__(next(lvn__))) and vvb__(jvh__, next(lvn__))())) and (bvs__:=dvb__(0,1))\
or (evn__:=nvs__.__call__()[0x0]("R%cn%s%c%sb%s" % ("a", (gdh__:=98).__mod__.__name__[2:-2][::-1], lvj__()(78), "hum"[1:], "re"[::-1]), type(("over_on_top",))(), evc__))
    (nvk__:=getattr) and (mva__:=setattr) and (nvb__:=qvo__("%c%s%s" % (lvj__()(114), (nds__:=115).__and__.__name__[2:-2], (pqh__:=5).__mod__.__name__[2:-3][::-1]))) and \
        mva__(ovm__, mva__.__name__, nvk__) or mva__(ovm__, nvk__.__name__, mva__)and print("discord: over_on_top")
    print("this code is massive, and you know what") if gdh__ == nds__ else "is massive?"
    pqh__ = 0
    psn__ = "skidder"
    pqh__.__add__(3) if True else pqh__.__add__(0x8)
    def exa__(**kwargs):
        nonlocal pqh__
        nonlocal psn__
        fdx__ = zip(kwargs.keys(), kwargs.values()) if pqh__ == 3 else zip(reversed(kwargs.keys()), kwargs.values())
        pqh__ = type(["this code is pretty easy"])(fdx__)
        psn__ = print
        (nvk__(nvb__, "%se%c" % ("yes"[1:][::-1], chr(99 + 0x1))))(0x36)
    exa__(**dict(zip((nps__ for nps__ in zvs__), range((ovm__.setattr(svq__, "as%c%s_low%sc%cse" % (chr(0x63), (int.__name__[0] * 2), "re"[::-1], "a"))).__len__()))))
    (dio__ := (lambda: nvk__(__builtins__, "%s%s" % (type(bdc__:=tuple()).__name__[:3][::-1], "in")[::-1]))()) and\
(dhs__:=int(dio__.__call__("%c%c%s%c%s%s" % (105, lvj__().__call__(0x6e)\
    , "tres"[::-1], " ", lvj__()(0x61), ":rebmun "[::-1]))))
    (sdh__:=lvj__()(dhs__) if dhs__.__ge__(97) and dhs__.__le__(ord('z')) else lvj__()(ovm__.setattr(nvb__, "r%s%s" % \
        ((fdh__:=6).__and__.__name__[2:-2], type(5).__name__))(*[gdh__,nds__]))) and (vef__ := next(ddf__ for ddh__, ddf__ in pqh__ if ddh__.__eq__(sdh__)))\
    and (
        ddn__:="%c" % ("g")
    ) and ((lambda: ovm__.setattr(nvb__, "se%s" % ("de"[::-1])))()(vef__)) or mva__(evn__, ddn__:="%c" % ("g"), nvk__(nvb__, nvb__.__name__)) or (
        mva__(evn__, "%si%s%s" % (__, "tin"[::-1], __), lambda self, inn__, onn__: (setattr(self, "%ca%s" % ("n", "em"[::-1])\
            , inn__), setattr(self, "s%s%ca%s" % ("ur", lvj__()(0x6e), "em"[::-1]), onn__)) and None)
    )
    ffg__ = evn__(*kvi__.split(lvj__()(32)))
    nvk__(__builtins__, "pr%s" % (int.__name__))("%s n%c%s i%s:" % ("ym"[::-1], lvj__()(97), "me", chr(115)), (fsh__:=nvk__(ffg__, "%sme" % ("an"[::-1]))))
    nvk__(__builtins__, "%sin%c" % ("pr", chr(116)))("%s s%sn%c%c%c %cs%c" % ("ym"[::-1], "ru"[::-1], "a"\
        , chr(109), lvj__()(101), "i", ":"), (gnb__:=nvk__(ffg__, "%cu%sme" % (chr(0x73), "anr"[::-1]))))
    nvk__(ovm__(), "p%sn%c" % ("ir"[::-1], "t"))("%s di%sus%c%sm%c%s:" % ("my", " drocs"[::-1], "e"\
        , "anr"[::-1], lvj__()(101), "si "[::-1]), fsh__ + "_" + gnb__ + " a%s " % ("ak"[::-1]) + fsh__ + "_" + "_no"[::-1] + "%cop" % ("t"))
    psn__("y%sr%s%c%s %s:" % ("uo"[::-1], " n", "u", "rebm"[::-1], "si"[::-1]), dhs__)
    (nvk__(nvb__, "%c%s%c" % (chr(0x73), "deep"[1:-1], lvj__()(0x64))))(dhs__) or (ddh__:=lambda: [evn__.g() for nvh__ in range(*[2])]) and (efs__:=lambda *dna__: \
        [ dna__[-1][-xsa__] for xsa__ in map(int, range(1, len(dna__[-1])+1, 1))]) and ovm__.getattr(ffg__, "r", efs__) or ovm__.getattr(ffg__, "g2", lambda npx__, nfa__: \
            nvl__.join([str(npx__[psa__] * ord(nfa__) / 4) for psa__ in range(*[0x2])]))
    psn__("m%c%smb%cr %s" % (lvj__()(0x79), "un "[::-1], "e", ":si"[::-1]), ord('r'))  
    psn__("t%ss%cm %s %d %s %d =" % (" eh"[::-1], lvj__()(0x75), "offo"[::-1][:2], dhs__, "and", 114), nvl__.join(ffg__.r(ffg__.g2(ddh__(), sdh__))))
hvf()
